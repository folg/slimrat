#!/usr/bin/env perl
#
# SlimRat 
# v0.9.4 (2009-xx-xx)
# PÅ™emek Vyhnal <premysl.vyhnal gmail com> 2009 
# public domain
#
# hasant.di.kampung.edan - wget options
# tim.besard
#


use FindBin qw($RealBin);
use lib $RealBin;

use Getopt::Long;
use Term::ANSIColor qw(:constants);
use Plugin;
use Toolbox;
use strict;
use warnings;
use Data::Dumper;
use POSIX 'setsid';


# config
our ($ccf, $ccs, $ccg);
do $RealBin."/config";


my ($list, $link, @links, $check, @failedlinks, @oklinks, $download_to, $address, $wget_opts, $unpack, @pass, $daemon);


sub usage { print "
SlimRat 

Downloads files from rapidshare and other servers to your working directory. Files to download are specified by download links like 'http://rapidshare.com/files/012345678/somefile.xxx' as arguments on command line or one per line in file given as --list option ('-' for stdin works too).

USAGE:
  $0 [options] [link [link [...]]]
		
OPTIONS:
  -h | --help              this help
  -d | --daemon            start as a daemon
  -l | --list   filename   load links from file (one per line)
  -c | --check             only check links, don't download them
  -t | --to     directory  destination directory (where to download)
  -a | --address host|ip   bind to specified address for download
  -w | --wget              wget options, enclosed in quotes
                           slimrat -w '--limit-rate=20k' -l file-list
"; exit; }

#  -u | --unpack            unpack downloaded archives
#  -p | --password          archive password


GetOptions (
		"help!"		=> \&usage,
		"check!"	=> \$check,
		"list=s"	=> \$list,
		"to=s"		=> \$download_to,
		"address=s"	=> \$address,
		"wget=s"	=> \$wget_opts,
		"unpack!"	=> \$unpack,
		"pass=s@"	=> \@pass,
		"daemon!"	=> \$daemon,
		);

&usage if(!scalar @ARGV && !$list); 

# Set socket local address if needed
if($address){
	no warnings; # avoid a "name used only once" warning
	push(@LWP::Protocol::http::EXTRA_SOCK_OPTS, LocalAddr => $address);
	$wget_opts .= " --bind-address='$address' ";
}

if($list){ # load links from file
	if(open (LIST, $list)){
		!m/^#/ and m/^\s*(\S+)\s*/ and push @links, $1 while(<LIST>);	# ignore comments
		close LIST;
	} else {warn "Can't open '$list'\n";}
}

push @links, $link while($link = shift); # read links from command line



my $return = 0; # navratova hodnota

if ($daemon){
	print &ptime."Becoming a daemon\n";
	daemonize();
	print "\n\n";
	$wget_opts .= " -q";	# avoid log file spam
	$wget_opts .= " -c";	# make wget continue if file exists
				# this is a temporary fix, because when slimrat receives a sig{int}
				# when downloading, wget will continue to download the file without
				# updating the urls-file. this can cause a file in the list to be
				# already downloaded, and to avoid wget redownload it we use this -c flag
}

print &ptime."Slimrat started\n";

if($check){
	foreach $link (@links) {
		check($link);
		print YELLOW, $link, RESET, " (", Plugin::get_name($link), ")\n";
	}
} else {
 	$SIG{'INT'} = 'quit';
	foreach $link (@links) {
		if (download($link)) {
			push @oklinks, $link;
			
			# update file: comment out link
			if ($list){
				if(open (LIST, $list)){
					open (LIST2, ">$list.temp");
					while(<LIST>){
						m/$link/ and print LIST2 "# DONE: ";
						print LIST2 $_;
					}
					close LIST;
					close LIST2;
					unlink $list;
					rename("$list.temp", $list);
				}
			}

			# custom command on successful download
			system($ccs);

		} else {
			push @failedlinks, $link;

			# custom command on failed download
			system($ccf);
		}
	}

	# custom command after all downloads
	system($ccg);

	&quit;
}






sub quit {
	if(scalar @oklinks){
		print GREEN, "\nDOWNLOADED:\n", RESET;
		print $_,"\n" foreach @oklinks;
		print "to '",YELLOW, $download_to, RESET, "'\n" if ($download_to);
	}
	if(scalar @failedlinks){
		print RED, "\nFAILED:\n", RESET;
		print $_,"\n" foreach @failedlinks;
	}
	print "\n".&ptime."Slimrat finished\n";
	
	# todo: kill any active wget instance
	
	# hard exit, for when &quit gets called out of sig{int}
	exit(0);
}



sub check{
	$link = shift;
	my $pluginname = Plugin::get_name($link);
	my $check = eval $pluginname."::check('$link')";
	$check ||=0;
	if($check>0) {print GREEN,  "[ALIVE] ", RESET;}
	elsif($check<0) {print RED, "[DEAD]  ", RESET; $return++}
	else {print GREEN, "[?]     ", RESET;}
	return $check;
}

sub download{
	$link = shift;

	my $pluginname = Plugin::get_name($link);
	print &ptime."Downloading ", YELLOW, $link, RESET, " ($pluginname) ";

	if (check($link) < 0){
		print RED "\n".&ptime."Download failed (dead link)\n";
		return 0;
	}
	print "\n";

	my $fileurl = eval $pluginname."::download('$link')";
	if($fileurl){ 
		my $command = 'wget ' .
			"-U \"$useragent\" ".
			($wget_opts ? qq($wget_opts ) : '') .
			($download_to? " -P \"$download_to\" " : "") .
			" \"$fileurl\"";

		if(!system($command)){ #success
			print GREEN &ptime."File downloaded", RESET, "\n\n";
			return 1;
		} else { # wget failed
			print RED &ptime."Download failed\n\n";
			return 0;
		}
	} else { # get fileurl failed
		print RED &ptime."Plugin failed\n\n";
		return 0;
	}
}

sub daemonize{
	chdir '/' or die "Can't chdir to /: $!";
	open STDIN, '/dev/null' or die "Can't read /dev/null: $!";
	if (! open STDOUT, '>>/var/log/slimrat.log'){ 
		print YELLOW &ptime."Could not redirect output to /var/log/slimrat.log, silencing slimrat.\n";
		open STDOUT, '>>/dev/null';
	}
	defined(my $pid = fork) or die "Can't fork: $!";
	exit if $pid;
	setsid or die "Can't start a new session: $!";
	open STDERR, '>&STDOUT' or die "Can't dup stdout: $!";
}

exit($return);
