#summary Instructions on how to develop a plugin for Slimrat.
#labels Featured,Phase-Implementation

= Introduction =

This page is meant to be a guide on plugin development. It describes which routines should be implemented, what their function signature is, and how they might be implemented.

This guide is based upon Slimrat 0.9.6, as of 2009-07-16 the *development version*. For information on earlier versions, have a look at existing plugins.



= Implementation =

Slimrat uses plugins to fetch data from a remote resource. The resource location is specified by a textual string, the Uniform Resource Locator (URL). URLs can point to several types of locations (a webserver like Rapidshare, some FTP server, a MMS multimedia server, ...), and a plugin has to be available to pass Slimrat the resource's data.

Every plugin has to be implemented in an object-oriented matter, which makes it possible to move certain actions to a constructor. Example: if the get_size as well as the get_filename function require the contents of an identical page, this could be handled in the constructor, or using a data container and flag.

== Register ==

For Slimrat to know which plugin to use to process a given URL, each plugin has to register itself using a static function. This is done by a regular expression, using which every given URL is attempted to be matched with

The following example code makes the plugin register itself to any URL containing rapidshare.com, it be over HTTP as well as FTP.
{{{
Plugin::register(__PACKAGE__,"^([^:/]+://)?([^.]+\.)?rapidshare.com");
}}}

== Constructor ==

The constructor has to create the initial object, initialising any needed objects in order to get the data later on. Most HTTP-based plugins will need a Mechanize object to click through forms, and a UserAgent object to download the data to a download processor.
{{{
sub new {
	my $self  = {};
	$self->{CONF} = $_[1];
	$self->{URL} = $_[2];
	
	$self->{UA} = LWP::UserAgent->new(agent=>$useragent);
	$self->{MECH} = WWW::Mechanize->new(agent=>$useragent);
	
	$self->{CONF}->add_default("interval", 0);
	
	bless($self);
	return $self;
}
}}}
The constructor is given the initial URL and a configuration object. The URL is saved for later on (get_data), and the configuration object is saved as well and can be used to query for user-configurable values.

When you want to use such user-configurable values, you need to specify a default value in the constructor though. In the constructor above one user-configurable value is registered (the maximal wait interval), and is set to be 0 by default. When a user specifies another interval value, the configuration object will appropriately return that value instead of the default one (don't worry: add_default won't ever overwrite an already saved user-defined value).
To use the "interval" value, you do as such:
{{{
sleep($self->{CONF}->get("interval"));
}}}

When the plugin should not be used yet (experimental, buggy, need to port, ...) the following code can be placed in the constructor:
{{{
return error("plugin not ported yet");
}}}
Or when depending on a user-configurable value:
{{{
return error("plugin disabled") unless $self->{CONF}->get("enabled");
}}}
As the constructor's return value is evaluated in the main application (0 for "plugin failure", 1 for "plugin success") and the error($) function always returns a 0, this code will make slimrat skip this URL for now. It won't mark it as "DEAD" though, as it's a plugin error and no link error.

== Plugin name ==

This function returns the name of the plugin. This can be descriptive (e.g. "MMS-stream over UDP") and does not have to be unique. This contrary to the package name, which has to be an unique identifier used internally to register the plugins ("Plugin::get_package($)").
{{{
sub get_name {
	return "Youtube";
}
}}}

== Filename ==

This method is used to determine the filename of the resulting (local) file. Popular HTTP download sites display the filename at the initial page, which would lead to code alike:
{{{
sub get_filename {
	my $self = shift;
	
	my $res = $self->{MECH}->get($self->{URL});
	if ($res->is_success) {
		if ($res->decoded_content =~ m/Filename: (.+)/) {
			return $1;
		} else {
			return 0;
		}
	}
	return 0;
}
}}}

Again, a return value of 0 will result in a "unknown filename".

== Filesize ==

This method returns the filesize in bytes. Returns 0 if unknown.

Function Toolbox::readable2bytes() can help with parsing values like '105 KB'.

{{{
sub get_filesize {
	my $self = shift;
	
	my $res = $self->{MECH}->get($self->{URL});
	if ($res->is_success) {
		if ($res->decoded_content =~ m/Filesize: (.+)/) {
			return readable2bytes($1);
		} else {
			return 0;
		}
	}
	return 0;
}
}}}

Return values analogue to the get_filename method.

== Check ==

This method should check if the passed URL is up and alive. It differentiates the failure return value however:
 * return -1, when the link is DEAD (the download site reported so)
 * return 0, when the plugin doesn't really know if the URL is dead (404, or unknown error)
 * return 1, link is up and alive, and can be downloaded.
{{{
sub check {
	my $self = shift;
	
	my $res = $self->{MECH}->get($self->{URL});
	if ($res->is_success) {
		# Check if the download form is present
		if ($res->decoded_content =~ m/click here to download) {
			return 1;
		} elsif ($res->decoded_content =~ m/link is dead/ {
			return -1;
		}
	}
	return 0;
}
}}}

== Get data ==

This is the main method of any plugin, and should download the data ant reroute it to the only parameter of the get_data method: a data processor routine.

In case of a HTTP-based download site, the process most of the times consists of three parts
 # Fulfil all prerequisites (click through some forms, fill in a captcha, ...)
 # Generate a final request which will download the file
 # Send the request, and reroute the output to the data processor

=== Method signature ===

This is the method description, accepting the extra parameter
{{{
sub get_data {
	my $self = shift;
	my $data_processor = shift;
}}}

=== Step 1: prerequisites ===

Most of the times this will fetch the initial page:
{{{
my $res = $self->{MECH}->get($self->{URL});
return error("plugin failure (", $res->status_line, ")") unless ($res->is_success);
}}}

Sometimes, you might need to click a specific button (e.g. Rapidshare's FREE button):
{{{
$self->{MECH}->form_number(1);
$res = $self->{MECH}->submit_form();
return error("plugin failure (page 2 error, ", $res->status_line, ")") unless ($res->is_success);
}}}

After having a page, some complex loops might be required to wait upon request, or to extract a code which is needed to download the actual site. An example of the EasyShare plugin:
{{{
my $code;
while (1) {
	my $content = $res->decoded_content."\n";
	
	# Wait timer?
	if ($content =~ m/You have to wait: (\d+)/) {
		# Wait
		dwait($1);
		# Eventually reload and restart the loop
	}
	
	# Code extraction
	if ($content =~ m/Magic code: (\d+)/) {
		$code = $1;
		print "Got captcha through button: $code\n";
		return error("plugin failure (could not extract captcha code)") unless $code;
		last;
	}
	
	# Wait if the site requests to
	if($content =~ m/some error message/) {
		my ($wait) = m/extract some (\d+) minutes/sm;		
		return error("plugin failure (could not extract wait time)") unless $wait;
		dwait($wait*60);
			$res = $self->{MECH}->reload();
		next;
	}
	
	# We got a problem here
	return error("plugin failure (could not match any action)");
}
}}}

=== Step 2: request generation ===

In case of a regular HTTP-GET request:
{{{
my $request = HTTP::Request->new(GET => $url_after_prerequisites);
}}}

Sometimes, a POST request with additional data is required:
{{{
my $req = HTTP::Request->new(POST => $url_after_prerequisites);
$req->content_type('application/x-www-form-urlencoded');
$req->content("magic_code=$code&foo=bar");
}}}

=== Step 3: Download ===

This is the easy part, which will send the request and reroute the output to the data processor.

In case of a regular HTTP request:
{{{
$self->{UA}->request($req, $data_processor);
}}}



= Notes =

== Error reporting ==

When a plugin needs to report an error, it should do that by returning the error() function:
{{{
return error("this is why the plugin failed")
}}}

This makes the plugin de-activate immediately, with an error message printed. As the error() function returns 0 by default, the caller will however also detect a failure, and might that way proceed to a next URL. As the return value is 0 and not -1, the URL won't be marked as "DEAD", but the failure shall be reported as a "plugin error" and the URL will be retried upon a next run.