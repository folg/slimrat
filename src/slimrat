#!/usr/bin/env perl
#
# slimrat - main CLI script
#
# Copyright (c) 2008-2009 Přemek Vyhnal
# Copyright (c) 2009 Tim Besard
#
# This file is part of slimrat, an open-source Perl scripted
# command line and GUI utility for downloading files from
# several download providers.
# 
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation
# files (the "Software"), to deal in the Software without
# restriction, including without limitation the rights to use,
# copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following
# conditions:
# 
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
# OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.
#
# Authors:
#    Přemek Vyhnal <premysl.vyhnal gmail com>
#    Tim Besard <tim-dot-besard-at-gmail-dot-com>
#

#################
# CONFIGURATION #
#################

#
# Dependancies
#

# Packages
use threads;
use threads::shared;
use Getopt::Long;
use Pod::Usage;

# Find root for custom packages
use FindBin qw($RealBin);
use lib $RealBin;

# Custom packages
use Common;
use Plugin;
use Toolbox;
use Queue;
use Log;
use Configuration;

# Function prototypes
sub quit($);

# Write nicely
use strict;
use warnings;


#
# Essential stuff
#

# Filthy debug flag prescan
foreach (@ARGV) {
	Log::set_debug() if (m/^--debug$/);
}

# Register signals
$SIG{'INT'} = 'quit';

# Global variables
my @failedlinks:shared;
my @oklinks:shared;


#
# Initialise configuration
#

# Process command-line options
Getopt::Long::Configure("pass_through");
Getopt::Long::Configure("bundling");

my %options;
GetOptions (
		\%options,
		"help|h|?",
		"man",
		"check|c",
		"list|l=s",
		"to|t=s",
		"address=s",
		"daemon|d",
		"kill|k",
		"debug",
		"quiet|q",
		"config=s",
);

# Initialise global configuration
my $config = config_init($options{"config"});
config_merge($config);

# Initialise own configuration
my $config_cli = new Configuration;
$config_cli->set_default("mode", "download");
$config_cli->set_default("to", ".");
$config_cli->set_default("threads", 1);
$config_cli->set_default("image_viewer", "asciiview -kbddriver stdin -driver stdout %s");
$config_cli->merge($config->section("cli"));

# Give the usage or manual
if ($options{"man"}) {
	pod2usage(-verbose => 2);
	quit(0);
} elsif ($options{"help"}) {
	pod2usage(-verbose => 1);
	quit(0);
}

# Kill an instance if requested
if ($options{"kill"}) {
	if (my $pid = pid_read()) {
		if (kill 0, $pid) {
			info("Killing an active instance at PID $pid");
			kill 2, $pid;
			quit(0);
		} else {
			warning("no running instance found");
			quit(1); # ?
		}
	} else {
		fatal("could not read state file");
		quit(255);
	}
}

# Mode (e.g. what slimrat should do)
$config_cli->set("mode", "check") if ($options{"check"});

# Options we might use later on
$config_cli->set("list", $options{"list"}) if ($options{"list"});
$config_cli->set("daemon", 1) if ($options{"daemon"});
$config_cli->set("address", $options{"address"}) if ($options{"address"});
$config_cli->set("to", $options{"to"}) if ($options{"to"});
usage("cannot combine --debug with --quiet option") if ($options{"quiet"} && $options{"debug"});
$config->section("log")->set("verbosity", 2) if ($options{"quiet"});
$config->section("log")->set("verbosity", 5) if ($options{"debug"});


#
# Apply configuration
#

# Display thread identification at output if requested
$config->section("log")->set("show_thread", 1) if ($config_cli->get("threads") > 1);

# Check if we got input files (if certain mode does not require those, prepend those checks _before_ this conditional)
if (!scalar @ARGV && !$config_cli->get("list")) {
	usage("no input URLs");
}

# Initialise a link queue
while (my $link = shift) {
	if ($link =~ /^\w+:\/\//) {
		Queue::add($link);
	} else {
		usage("unrecognised option \"$link\"");
	}
}
Queue::file($config_cli->get("list")) if ($config_cli->get("list"));

# Set socket local address if needed
if($config_cli->get("address")){
	no warnings;
	push(@LWP::Protocol::http::EXTRA_SOCK_OPTS, LocalAddr => $options{"address"});
}

# Fork in background
if ($config_cli->get("daemon")) {
	info("Forking in background");
	daemonize();
	print "\n\n";
}



########
# MAIN #
########

info("Slimrat started (command-line interface)");
warning("this is a development release, if you encounter any issues, please re-run slimrat with the '--debug' flag enabled, and submit the resulting dump file to the bug tracker");

#
# Check
#

if ($config_cli->get("mode") eq "check") {
	info("Checking URLs");
	my $dead_links = 0;
	
 	# Instantiate per-thread objects
	my $mech = config_browser();
	my $queue = new Queue();
	
	# Get and loop all URLs
	$queue->advance();
 	while (my $link = $queue->get()) {
		my $alive = 0;
		debug("checking '$link'");
		
		# Load plugin
		my $plugin;
		unless ($plugin = Plugin->new($link, $mech)) {
			status($link, 0, "plugin failure");
		} else {
			my $status = $plugin->check();
			if ($status < 0) {
				status($link, $status, "file is dead");
			} elsif ($status == 0) {
				status($link, $status, "plugin failure (could not distinguish whether file is up or down)");
			} elsif ($status > 0) {
				my $size = $plugin->get_filesize();
				my $extra = ($plugin->get_filename()||"unknown filename") . ", " .  ($size ? bytes_readable($size) : "unknown filesize") if ($status>0);
				status($link, $status, $extra);
				$alive++
			}
		}
		$dead_links++ unless ($alive);
		
		# Advance to the next URL
		$queue->advance();
	}
	
	quit($dead_links);
}


#
# Download
#

elsif ($config_cli->get("mode") eq "download") {
	# Spawn threads
	my $threads = $config_cli->get("threads");
	debug("spawning $threads download threads");
	for (my $i = 0; $i < $threads; $i++) {
		my $thread = threads->create(\&thread_download);
	}
	
	# Wait till all threads finish
	while (scalar(threads->list(threads::running))) {
		sleep(1);
	}

	# Command after all downloads
	if (my $command = $config_cli->get("post_all")) {
		system($command);
	}
	
	# Quit
	quit(scalar @failedlinks);
}


#
# Other
#

else {
	usage("unrecognised mode");
	quit(255);
}



############
# ROUTINES #
############

# Download thread
sub thread_download {
 	# Instantiate per-thread objects
	my $mech = config_browser();
	my $proxy = new Proxy($mech);
	my $queue = new Queue();
	
	# Load the first URL
	$queue->advance();
 	while (my $link = $queue->get()) {		
 		# Load a proxy
 		$proxy->advance($link);
 		
 		# Download the URL with custom progress indication
 		my $failure = 0;
		my $result = download(
				$mech,
				$link,
				$config_cli->get("to"),
				sub { # Progress indication
					my ($done, $total, $speed, $eta) = @_; # Bytes downloaded, Filesize in bytes, Bytes downloaded from last run of this function, Time from last run
					if ($total) {
						my $perc = $done / $total;
						push my @progr, "Downloaded: ", int($perc*10000)/100, "%";
						push @progr, " -- speed: ", bytes_readable($speed), "/s -- ", seconds_readable($eta), " remaining" if ($speed);
						progress(@progr);
					} else {
						push my @progr, "Downloaded ", bytes_readable($done);
						push @progr, " -- speed: ", bytes_readable($speed), "/s" if ($speed);
						progress(@progr);
					}
				},
				sub { # Captcha handler
					my $captchafile = shift;
					
					# view
					system(sprintf $config_cli->get("image_viewer"), "/tmp/slimrat-captcha.tmp");
					
					# Ask the user
					print "Captcha? ";
					my $captcha = <>;
					chomp $captcha;
					return $captcha;
				}
		);
		
		# Check result
		if ($result > 0) {
			push @oklinks, $link;
			$queue->skip_globally("DONE");

			# Command after successful download
			if (my $command = $config_cli->get("post_download")) {
				system($command);
			}
		}
		elsif ($result == -2) {
			debug("could not allocate resources");
			$queue->skip_locally();
		} elsif ($result == -1) {
			$failure = 1;
			$queue->skip_globally("DEAD");
		} elsif ($result == 0) {
			$failure = 1;
			$queue->skip_globally();
		}
		
		# Failure?
		if ($failure) {
			push @failedlinks, $link;

			# Command after failed download
			if (my $command = $config_cli->get("post_failure")) {
				system($command);
			}
		}
		
		# Advance to the next URL
		while (! $queue->advance()) {
			warning("thread couldn't get any work, exiting");
			return 1;
		}
	}
}

# Finish
sub quit($) {
	# Print a download summary
	summary(\@oklinks, \@failedlinks);
	
	# Join finished threads
	$_->join() foreach (threads->list(threads::joinable));
	
	# Quit all packages
	Common::quit(@_);
}



#################
# DOCUMENTATION #
#################

=head1 NAME

slimrat-cli

=head1 VERSION

1.0.0-trunk

=head1 DESCRIPTION

  Command-line download manager, capable of downloading files from
  several free download providers.

=head1 SYNOPSIS

  slimrat [OPTION...] [LINK]...

=head1 OPTIONS

=over 8

=item B<--help>

  Prints a summary how to use the client.

=item B<--man>

  Prints a manual how to use the client.

=item B<--daemon>

  Makes slimrat work in the background, by properly forking and redirecting
  the output to a specified logfile. Only one file can be backgrounded at a
  time, to support multiple instances you'll need to specify differend
  state files to save the instances PID in.

=item B<--kill>

  Kills a single active client, by looking up the PID in a predefined state file.

=item B<--list>

  Uses the given file as a queue-file containing URLs.

=item B<--check>

  Do not download the loaded URLs, just check them.

=item B<--to>

  Specifies the target directory for the downloaded files.

=item B<--address>

  Makes the download client bind to a specific address.

=item B<--config>

  Load custom configuration file.

=item B<--debug>

  Enables maximal verbosity, which includes a lot of text on the screen and the generation
  of an additional dump archive.
  WARNING: do not use this option by default, as it keeps a whole lot of extra information
           in memory (including _all_ downloaded items).

=item B<--quiet>

  Makes slimrat less verbose, only displaying errors and warnings.

=back

=head1 EXAMPLES

  slimrat http://rapidshare.com/files/012345678/somefile.xxx
  slimrat -l urls.dat -d

=head1 AUTHOR

Přemek Vyhnal <premysl.vyhnal gmail com>
Tim Besard <tim-dot-besard-at-gmail-dot-com>

=cut

